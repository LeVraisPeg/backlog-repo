\documentclass{article}
\usepackage{amsmath, amssymb, geometry}
\usepackage{tikz}
\usepackage{titlesec}
\usepackage{lmodern}
\usepackage[french]{babel}
\usepackage{hyperref}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\geometry{a4paper, margin=2.5cm}
\date{\vspace{1cm} \today}

\begin{document}

    \begin{titlepage}
        \centering
        \begin{tikzpicture}[remember picture, overlay]
            \node[opacity=0.1] at (current page.center) {\includegraphics[width=\paperwidth,height=\paperheight,keepaspectratio]{image.png}};
        \end{tikzpicture}

        \vspace*{2cm}

% Titre principal
        {\Huge\bfseries Compte Rendu de Projet\\[0.5em] \LARGE SAE821 -- Gérer un projet}

        \vspace{1.5cm}

% Ligne de séparation
        \HRule
        \vspace{1cm}

% Informations sur les auteurs
        \Large{Rapport de présenation de la modélisation d'un système de recommandation  respectant la vie privée}\\[0.5em]

        \vspace{1cm}
        \HRule\\[11cm]
        \begin{flushleft}
            \small
            \textbf{Pegliasco Matteo}\\
            \textbf{Berge Enzo}\\
            \textbf{Audouard Florian}\\
            \textbf{Hermelin Lois}\\
            \textbf{Master Informatique et Mathématiques}\\
            Université de Toulon, La Garde, Var, France
        \end{flushleft}
        \vfill

    \end{titlepage}


    \tableofcontents
    \newpage

    \section*{Introduction}
    Ce rapport technique est un comtpe rendu dans le cadre de la SAE821 dont l'objectif est la conception et la modélisation d’un système de recommandation respectueux de la vie privée des utilisateurs. Les systèmes de recommandation sont aujourd’hui omniprésents dans de nombreux domaines, notamment sur les plateformes de commerce en ligne, les réseaux sociaux ou encore les services de streaming. Ils permettent d’orienter les utilisateurs vers des contenus pertinents en se basant sur l’analyse de leurs comportements et préférences.
    Cependant, pour la majorité, ce traitement massif de données personnelles soulèvent des problématiques importantes liées à la protection de la vie privée, l'intégritée et la sécurité des données. Il est donc essentiel de réfléchir à des solutions techniques permettant de préserver la confidentialité des données tout en maintenant l’efficacité des recommandations.
    L’objectif de ce projet est de modéliser un système de recommandation de films prenant en compte tout ces critères, en utilisant des méthodes préservant la protection des données utilisateurs. Ce rapport présentera les différentes étapes de la modélisation, les choix techniques réalisés, ainsi que les méthodes mises en œuvre pour concilier personnalisation et respect de la vie privée.

    \section{Recherches théoriques}
    \subsection{Systèmes de recommandation}
    \subsubsection{Comprendre les Systèmes de Recommandation}
    Les systèmes de recommandation sont devenus des outils incontournables au fils du temps. Ils permettent aux utilisateurs d'être dirigé vers des contenus pertinents et personnalisés parmi une mutilitude de choix, en s'appuyant sur des données comportementales, des préférences et des connaissances du contexte. Cette recherche retrace l'évolution des approches de recommandation, de leurs fondements les plus simples à des méthodes d'intelligence artificielle avancée, en s'appuyant sur l'article : \href{https://medium.com/@eliasah/delving-deeper-into-recommender-systems-from-basics-to-state-of-the-art-d92ee8e277f2}{ Delving Deeper into Recommender Systems: From Basics to State-of-the-Art.}
    \subparagraph{Evolution Chronologique}

    \begin{itemize}
        \item Années 1990 - Premiers Modèles:

        \textbf{Le Filtrage Collaboratif (CF)} repose sur l'idée que des utilisateurs ayant patagé des préférences similaires dans le passé auront probablement des préférences semblables à l'avenir. Il existe deux variantes:
        \begin{itemize}
            \item \textbf{User-based CF: }recherche des utilisateurs similaires à l'utilisateur cible pour recommander les objets qu'ils ont aimés.
            \item \textbf{Item-based CF: }recherche des objets similaires à ceux déjà aimés par l'utilisateur pour proposer des recommandations
        \end{itemize}
        \textbf{Filtrage basé sur le Contenue (CB)} s'appuie uniquement sur les comportements passés de l'utilisateur, en particulier ses interactions avec certains objets. Contrairement au CF, il ne tient pas compte de la communauté mais des caractéristiques des éléments.
        \newline

        \item Années 2000 - Hybridation et Deep Learning:

        \textbf{Modèles hybrides} Ces modèles combinent CF et CB pour bénéficier de leurs avantages respectifs et une amélioration du démarrage à froid.

        \textbf{Début de l'apprentissage profond} L'arrivée du deep learning a introduit une nouvelle manière de représenter utilisateurs et objets à l'aide de réseaux de neurones capables d'extraire des caractéristiques complexes, non linéaires et profondes.
        \newline
        \item Années 2010 - Contexte et Connaissances:

        Les systèmes de \textbf{context-aware} prennent maintenant en compte des informations telles que le temps, la localisation, le dispositif utilisé ou encore l'état émotionnel.

        Les systèmes \textbf{knowledge-bases}, eux, utilisent des bases de connaissance et des bases de règles explicites pour mieux cerner les besoins utilisateurs, particulièrement utiles dans des cas de niches où les données sont rares.
        \newline
        \item Années 2020 - Intelligence Renforcée et Explicabilité:

        \textbf{La Recommandation par Apprentissage par Renforcement (RL)} permet une approche sequentille et interactive. Le système apprend à adapter ses recommandations en fonction des réactions de l'utilisateur. L'algorithme explore l'espace des solutions pour améliorer ses retours.

        \textbf{La Recommandation Explicable} fournit une justification compréhensible à l'utilisateur, améliorant ainsi la confiance et la transparence
    \end{itemize}

    \subparagraph{Types de Systèmes de recommandation:}
    \begin{itemize}
        \item \textbf{Basé sur la mémoire}: Filtrage collaboratif simple
        \item \textbf{Basé sur un modèle}: Factorisation de matrice, réseaux de neurones, SVD
        \item \textbf{Basé sur le contenu}: utilisation des attributs des objets
        \item \textbf{Modèles hybrides}: Combine le filtrage collaboratif et filtrage basé sur le contenue
        \item \textbf{Apprentissage profond}: Réseaux de neurones
        \item \textbf{Système Contextuels}: Tiennent compte du contexte d'utilisation
        \item \textbf{Basé sur les connaissances}: Utilisent des logiques de règles, des bases de fait et ontologies
        \item \textbf{Apprentissage par renforcement}: Tiennent compte d'une interaction avec le client
        \item \textbf{Explicabilité}: Fournit une approche plus transparantes
        \item \textbf{Mutimodalité}: Combines plusieurs types de données
        \item \textbf{Protection de la vie Privée}: Utilise des techniques pour définir une forme de protection des résultats de requêtes
    \end{itemize}

    \subparagraph{Méthodes Avancées: }

    \begin{enumerate}
        \item \textbf{Filtrage Collaboratif avec ALS} (Alternating Least Squares) :

        Repose sur le fait que deux utilisateurs ayant eu des opinions similaires auront des opinions similaires ans d'autres situations. Utilise la factorisation de matrice avec une méthode d'optimisation par moindrers carrés alternés.
        \item \textbf{Singular Value Decomposition} (SVD):

        Utilisation d'une matrice de notes \(R = (utilisateur*items)\), la SVD la décompose comme : \(R \approx U . \sum .
        V^t\)

        \begin{itemize}
            \item U = matrice des facteurs latents utilisateur
            \item \(\sum=\) matrice diagonal des valeurs singulières
            \item \(V^t=\) transposé de la matrice des facteurs latents des items
        \end{itemize}
        SVD version recommandation:

        Factorisation de la Matrice \(\hat{R}_{ui} = P_u^T Q_i \)
        \newline
        \( R_{ui} = \) note prédite par l'utilisateur \(u\) pour l'item \(i\)
        \newline
        \(P_u = \) vecteur latent de l'utilisateur \(u\) (préférences)
        \newline
        \(Q_i = \) note vecteur latent de l'item\(i\) (caractéristiques)
        \newline
        Le produit scalaire donne la note préditque de \(u\) donnerait à \(i\).

        Apprentissage de \(P\) et \(Q\): \[ \min_{P, Q} \sum_{(u,i) \in K} \left( R_{ui} - P_u^T Q_i \right)^2 + \lambda \left( \lVert P_u \rVert^2 + \lVert Q_i \rVert^2 \right)\]

        Avec \(K\) l'ensemble des paires utilisateur-item connues (données d'entraînement), \(R_{ui}\) note réelle et \(\lambda\) le coefficient de régularisation

        \item \textbf{Recurrent Neural Network} (RNN):

        Le réseau de neurones permet de traiter des séquences (texte, audio, clics, utilisations ...) Il possède une mémoire interne (qui utilise l'info précédente à chaque étape) et gère les dépendances temporelles.

        À chaque instant (t), le RNN reçoit une entrée \((x_t)\) et un état caché précédent \((h_{t-1})\), puis il calcule:
        \begin{itemize}
            \item L'État caché: \(h_t = \tanh(W_h h_{t-1} + W_x x_t + b)\)
            \item  La Sortie: \(y_t = \text{softmax}(W_y h_t + b_y)\)
        \end{itemize}
        Avec :\\
        - \( h_t \) = état caché (mémoire interne) à l’instant \( t \)\\
        - \( x_t \) = entrée à l’instant \( t \)\\
        - \( y_t \) = sortie prédite à l’instant \( t \)\\
        - \( W_h, W_x, W_y \) = matrices de poids\\
        - \( b, b_y \) = biais\\
        - \( \tanh \) = fonction d’activation\\
        - \( \text{softmax} \) = utilisée pour une prédiction de classe\\

        \item \textbf{ConvNet} (CNN):\\
        Modèle de traitement spation de données (image, audio, vidéos):
        \begin{itemize}
            \item \textbf{Convolutions:} Extraction de caractéristiques locales
            \item \textbf{Pooling:} Reduction dimensionnelle
            \item \textbf{Fattening:} Prise de décision finale
        \end{itemize}

        \item \textbf{Multi-Armed Bandit: }\\
        Approche d'apprentissage par renforcement, visant à maximiser les gains et explorer l'espace d'action tout en exploitant les meilleures options (permet de recommander tout en testant de nouvelles options).


    \end{enumerate}

    \subsubsection{Collaborative filtering}
    Le filtrage collaboratif est une méthode de recommandation qui repose sur l’exploitation des interactions passées entre les utilisateurs
    et les objets.
    Contrairement au filtrage basé sur le contenu, il ne nécessite aucune information sur les caractéristiques des objets recommandés.

    \subparagraph{Fonctionnement}
    \begin{enumerate}
        \item \textbf{Collecte de données} : Récupération des interactions entre utilisateurs et objets, sous forme explicite (notes, avis) ou implicite (clics, temps passé, etc.).

        \item \textbf{Construction de la matrice utilisateur-objet} : Création d’une matrice où les lignes représentent les utilisateurs, les colonnes les objets, et les cellules contiennent les interactions.

        \item \textbf{Mesure de similarité} : Calcul de la similarité entre utilisateurs (user-based) ou entre objets (item-based) à l’aide de fonctions telles que la similarité cosinus ou le coefficient de corrélation de Pearson.

        \item \textbf{Prédiction} : Estimation de la préférence d’un utilisateur pour un objet non encore évalué, en se basant sur les préférences des utilisateurs ou objets similaires.

        \item \textbf{Génération de recommandations} : Sélection des objets les plus susceptibles d’intéresser l’utilisateur cible.
    \end{enumerate}

    \subparagraph{Exemple illustratif}
    Considérons la matrice suivante représentant les notes de films par trois utilisateurs :

    \begin{center}
        \begin{tabular}{|c|c|c|c|c|}
            \hline
            & Film A & Film B & Film C & Film D \\
            \hline
            Utilisateur 1 & 5 & ? & 4 & 2 \\
            \hline
            Utilisateur 2 & 4 & 3 & 5 & 1 \\
            \hline
            Utilisateur 3 & 2 & 4 & 1 & 5 \\
            \hline
        \end{tabular}
    \end{center}

    Ici, le système peut prédire la note que l'utilisateur 1 donnerait au \textit{Film B}, en se basant sur les préférences des utilisateurs 2 et 3, jugés similaires selon leurs comportements passés.

    \subparagraph{Avantages}
    \begin{itemize}
        \item \textbf{Pas besoin de métadonnées} : Il peut fonctionner sans connaître les caractéristiques des objets à recommander.
        \item \textbf{Recommandations personnalisées} : Il permet de proposer des contenus pertinents et parfois inattendus grâce à l’analyse des préférences collectives.
        \item \textbf{Adaptabilité} : Le système évolue avec les comportements des utilisateurs, ce qui le rend dynamique.
    \end{itemize}

    \subparagraph{Inconvénients}
    \begin{itemize}
        \item \textbf{Problème du démarrage à froid (cold start)} : Difficile de faire des recommandations précises pour un nouvel utilisateur ou un nouvel objet sans historique d'interactions.
        \item \textbf{Sparsité des données} : Les matrices utilisateur-objet sont souvent très clairsemées, ce qui complique la détection de similarités fiables.
        \item \textbf{Dépendance au comportement collectif} : Il peut recommander des objets peu pertinents si les utilisateurs similaires ont des goûts trop différents ou incohérents.
    \end{itemize}

    \subparagraph{Applications}
    \begin{itemize}
        \item \textbf{Divertissement} : Netflix, Spotify pour recommander des films ou de la musique.
        \item \textbf{E-commerce} : Amazon pour proposer des produits selon les comportements d’achat d’utilisateurs similaires.
        \item \textbf{Éducation} : Recommandation de cours ou ressources pédagogiques.
        \item \textbf{Réseaux sociaux} : Suggestion de contacts, contenus ou groupes.
    \end{itemize}

    \subsubsection{Matrix factorization}

    \subsubsection{Chaine de Markov}


    \section{Système de recommendation à froid}

    \subsection{Confidentialité}
    \subsubsection{Homomorphic encryption}
    $ $\\
    Le chiffrement homomorphe est une technique de cryptographie qui permet d'effectuer des calculs sur des données chiffrées sans avoir besoin de les déchiffrer au préalable mais dont le résultat déchiffré conserve les opérations entre les données claires.
    Pour cela, plusieurs catégories de chiffrements existent:\\
    \begin{itemize}
        \item \textbf{Chiffrement partiellement homomorphe}: Il permet de réaliser des opérations sur des données chiffrées pour une loi spécifique, par exemple l'addition ou la multiplication entre des données chiffrées.
        \item \textbf{Chiffrement presque entièrement homomorphe}: Il permet de réaliser un nombres limité d'opérations sur des données chiffrées pour plusieurs lois spécifiques, par exemple l'addition et la multiplication entre des données chiffrées, à cause d'une accumulation de bruit.
        \item \textbf{Chiffrement entièrement homomorphe}: Il permet de réaliser un nombre illimité d'opérations sur des données chiffrées pour toutes les lois possibles, mais il est limité par la taille du bruit accumulé lors des opérations.
    \end{itemize}
    $ $\\
    Dans le cadre de ce projet nous nous sommes intéressés particulièrement au chiffrement entièrement homomorphe pour sa flexibilité d'utilisation pour différents système de recommandations.\\
    Ainsi, plusieurs approches existent pour la mise en place du chiffreemnt homomorphe: \\
    \begin{itemize}
        \item \textbf{Chiffrement DGHV avec bootstrapping \cite{boots}}: Le chiffrement DGHV \cite{dghv} est un système de chiffrement homomorphe, opérant sur des entiers, basé sur le problème de la somme de sous-ensembles clairsemée et le problème du PGCD approché.
        \item \textbf{Chiffrement GSW avec bootstrapping\cite{boots}}: Le chiffrement GSW \cite{gsw} est un système de chiffrement homomorphe, opérant sur des bits, basé sur le problème de la factorisation des entiers et le problème du logarithme discret.
        \item \textbf{Chiffrement TFHE}: Le chiffrement TFHE est un système de chiffrement homomorphe, opérant sur des bits, basé sur la version torique du problème Learning With Errors.
    \end{itemize}
$ $\\
Toutefois, même si si le chiffrement homomorphe permet de préserver la confidentialité des données, leurs utilisations présentent plusieurs contraintes:
\begin{itemize}
    \item Les données chiffrées sont généralement plus volumineuses que les données claires, ce qui peut poser des problèmes de stockage et de transmission de données.
    \item L'utilisation des opérations sur des données chiffrées sont plus lentes que les données claires et l'utilisation de "bootstrapping" pour limiter l'accumulation de bruit
    augmentent aussi le temps de calcul.
    \item La mise en place sans ressouces externes est complexe et les ressources externes - sans prendre en compte leurs fiabilités - sont principalement disponible avec des bibliothèques
    \item en C++ ou RUST, comme Microsoft SEAL, HElib ou PALISADE, ce qui complique l'interaction avec d'autres langages de programmation comme JAVA.
\end{itemize}

\subsubsection{Differential privacy}
$ $\\
La confidentialité différentielle est une approche qui vise à garantir la protection de la vie privée des individus dans les ensembles de données en restreignant la relation entre les données de sortie et les données de l'utilisateur.
Pour cela, plusieurs approches existent:\\
\begin{itemize}
    \item \textbf{Mécanisme exponentiel}: Le mécanisme exponentiel permet de sélectionner aléatoirement un élément parmi un ensemble de données, en favorisant les éléments ayant le plus de poids selon une fonction d'évaluation donnée.
    \item \textbf{Réponse aléatoire}: Le mécanisme de réponse aléatoire vise à brouiller les réponses données en remplaçant aléatoirement certaines réponses par des valeurs aléatoires.
    En connaissant la probabilité d'obtenir une valeur aléatoire, il est alors possible d'estimer la proportion de données réelles ainsi que la variance au sein des données.
    \item \textbf{\emph{K-anonymisation} et \emph{L-diversité}}: La \emph{K-anonymisation}\cite{kanonymisation} et la \emph{L-diversité} consistent à masquer les éléments de quasi-identification d'un
    individu en le regroupant avec $K-1$ autres individus dans une représentations plus large, tout en conservant la visibilité des $L$ informations spécifiques à chaque utilisateurs et destinées à être partagées.
    \item \textbf{Mécanisme de Laplace ou Gaussien}: Le mécanisme de Laplace ou Gaussien \cite{laplace&gauss} consiste à altérer les données des utilisateurs pour masquer les données réelles tout en conservant la répartition moyenne des données en ajoutant un bruit aléatoire.
\end{itemize}

\section{Démarche choisie}
\subsection{Motivations du choix}
\subsubsection{Confidentialité des données}
$ $\\
Le cadre de ce projet est de mettre en place un système de recommandation de films respectant la vie privée des utilisateurs. Nous avons
considéré que la base de données des utilisateurs ainsi que les films proposés pouvaient évoluer au fil du temps.
Pour la protection de la vie privée des utilisateurs, nous avions considéré l'utilisation du chiffrement homomorphe TFHE, mais
la complexité de son implémentation et de son utilisation, avec notamment l'interaction entre différents langages de programmation (JAVA, C++, RUST),
ainsi que la complexité de l'utilisation de l'apprentissage machine avec une bibliothèque spécialisée, nous a poussés à nous intéresser davantage à la confidentialité différentielle.\\
Plus précisément, nous nous sommes particulièrement intéressés à la mise en place du mécanisme de bruitage et du mécanisme exponentiel pour la mise
en place de la confidentialité différentielle pour, respectivement, les recommandations pour un nouvel utilisateur et les recommandations personnalisées
d'un utilisateur ayant déjà évalué une certaine quantité de films.\
En ce qui concerne le mécanisme de génération du bruit, nous avons choisi d'utiliser le mécanisme de Laplace pour masquer les données des utilisateurs.\
Ce choix est motivé par le contexte de ce projet. En effet, les utilisateurs peuvent modifier leur evaluation d'un film. Dans cet optique, et contrairement au 
mécanisme gaussien, nous avons favorisé le mécanisme de Laplace car c'est un mécanisme $\epsilon$-indistinguable. C'est-à-dire qu'il garantit qu'une 
modification d'une entrée dans une base de données crée une modification bornée de la distribution de probabilité.\
De plus, étant donné que la base de données initale possède relativement peu d'évaluation utilisateurs pour chaque film, le mécanisme de Laplace est privilégié
puisque la génération de bruit à forte valeur est moins probable que pour le mécanisme gaussien, dû à une distribution plus centré en 0 pour la courbe Laplacienne, 
ce qui permet de garantir une meilleure précision dans l'étude de la moyenne des évaluations des films.\\
Enfin, dans le cadre d'une protection des données privée des utilisateurs, nous avons eu la volonté de limité l'utilisation de ressources externes 
pour la génération des données bruitées afin de reposer au minimum sur la fiabilité de ces ressources. Ce faisant, l'implémentation du mécanisme Gaussien 
impliquerait l'implémentation complexe, avec le temps disponible, de l'approximation de l'inverse de la fonction:
\begin{equation}
    F(x) = \int_{-\infty}^{x} \frac{1}{\sqrt{2\pi}} e^{-\frac{t^2}{2}} dt
\end{equation}
afin de générer le bruit gaussien. Ainsi, nous avons privilégié l'implémentation plus simple du mécanisme de Laplace qui s’adapte mieux aux traitements 
ponctuels sur des bases de données de taille variable, ccorrespondant aux besoins de notre système d'entrainement pour nos recommandations.\
En complément, et comme présenté précédemment, nous avons considéré l'utilisation du mécanisme exponentiel pour une sélection aléatoire biaisée d'un film recommandé.
Cette approche permet à la fois de favoriser certains films - ici ceux qui ont une note moyenne la plus éloigné de 2.5 pour recommender des films qui n'ont jamais été noté ou des
films avec une bonne notation - grâce à une fonction d'utilité définie dans le système, tout en limitant le risque que 
l'utilisateur puisse extraire des informations individuelles sur les autres utilisateurs ayant permis de générer les recommandations avec une bonne 
calibration.

\subsubsection{Models de recommandations}

Pour le système de recommendation, nou savons choisi de mettre en place deux approches pour la recommandation de films: un systeme se basant sur le SVD pour un 
individus connu par le système - individu ayant déjà noté un certain nombre de films - et un autre système de recommendation basé sur la clustering non supervisé 
pour la recommendation à froid pour un nouvel utilisateur.


    \subsection{Implémentation dans le système}
    \subsection{Limites et perspectives}


    \section{Résultats expérimentaux}
    \subsection{Précision des recommandations}
    \subsection{Performances computationnelles}
    \subsection{Mesure de la confidentialité}
    \subsection{Résumé}

    \section*{Références}
    \addcontentsline{toc}{section}{Références}

\begin{thebibliography}{9}

\bibitem{kanonymisation}
Wikipedia. \emph{K-anonymisation}.\\
\url{https://fr.wikipedia.org/wiki/K-anonymisation}

\bibitem{psychologie}
Revue de psychologie. \emph{La technique de la réponse aléatoire : un moyen de contrôler la désirabilité sociale dans la mesure de l'estime de soi}.\\
\url{https://www.persee.fr/doc/bupsy_0007-4403_1979_num_33_343_1128}

\bibitem{laplace&gauss}
Wikipedia. \emph{Additive noise differential privacy mechanisms}.\\
\url{https://en.wikipedia.org/wiki/Additive_noise_differential_privacy_mechanisms}


\bibitem{mecanism_comparaison}
Github. \emph{Exploring Differential Privacy: Laplace vs Gaussian}
\url{https://lpanavas.github.io/mechanism-comparison/}

\bibitem{dghv}
Goblé E. and Gatelier R.\emph{Le chiffrement DGHV}
\url{https://www.utc.fr/~wschon/sr06/tx_chiffrement_homomorphe/pages/dghv.html}

\bibitem{gsw}
Goblé E. and Gatelier R.\emph{GSW}
\url{https://www.utc.fr/~wschon/sr06/tx_chiffrement_homomorphe/pages/vecteurs_propres_approx.html}

\bibitem{boots}
Goblé E. and Gatelier R.\emph{Le Bootstrap}
\url{https://www.utc.fr/~wschon/sr06/tx_chiffrement_homomorphe/pages/bootstrapping.html}


\end{thebibliography}
    \section*{Annexes}
    \addcontentsline{toc}{section}{Annexes}
    Données supplémentaires, résultats détaillés, ou code pertinent.

\end{document}
