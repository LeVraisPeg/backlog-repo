\documentclass{article}
\usepackage{amsmath, amssymb, geometry}
\usepackage{tikz}
\usepackage{titlesec}
\usepackage{lmodern}
\usepackage[french]{babel}
\usepackage{hyperref}
\newcommand{\HRule}{\rule{\linewidth}{0.5mm}}
\geometry{a4paper, margin=2.5cm}
\date{\vspace{1cm} \today}

\begin{document}

    \begin{titlepage}
        \centering
        \begin{tikzpicture}[remember picture, overlay]
            \node[opacity=0.1] at (current page.center) {\includegraphics[width=\paperwidth,height=\paperheight,keepaspectratio]{image.png}};
        \end{tikzpicture}

        \vspace*{2cm}

% Titre principal
        {\Huge\bfseries Compte Rendu de Projet\\[0.5em] \LARGE SAE821 -- Gérer un projet}

        \vspace{1.5cm}

% Ligne de séparation
        \HRule
        \vspace{1cm}

% Informations sur les auteurs
        \Large{Rapport de présenation de la modélisation d'un système de recommandation  respectant la vie privée}\\[0.5em]

        \vspace{1cm}
        \HRule\\[11cm]
        \begin{flushleft}
            \small
            \textbf{Pegliasco Matteo}\\
            \textbf{Berge Enzo}\\
            \textbf{Audouard Florian}\\
            \textbf{Hermelin Lois}\\
            \textbf{Master Informatique et Mathématiques}\\
            Université de Toulon, La Garde, Var, France
        \end{flushleft}
        \vfill

    \end{titlepage}


    \tableofcontents
    \newpage

    \section*{Introduction}
    Ce rapport technique est un comtpe rendu dans le cadre de la SAE821 dont l'objectif est la conception et la modélisation d’un système de recommandation respectueux de la vie privée des utilisateurs. Les systèmes de recommandation sont aujourd’hui omniprésents dans de nombreux domaines, notamment sur les plateformes de commerce en ligne, les réseaux sociaux ou encore les services de streaming. Ils permettent d’orienter les utilisateurs vers des contenus pertinents en se basant sur l’analyse de leurs comportements et préférences.
    Cependant, pour la majorité, ce traitement massif de données personnelles soulèvent des problématiques importantes liées à la protection de la vie privée, l'intégritée et la sécurité des données. Il est donc essentiel de réfléchir à des solutions techniques permettant de préserver la confidentialité des données tout en maintenant l’efficacité des recommandations.
    L’objectif de ce projet est de modéliser un système de recommandation de films prenant en compte tout ces critères, en utilisant des méthodes préservant la protection des données utilisateurs. Ce rapport présentera les différentes étapes de la modélisation, les choix techniques réalisés, ainsi que les méthodes mises en œuvre pour concilier personnalisation et respect de la vie privée.

    \section{Recherches théoriques}
    \subsection{Systèmes de recommandation}
    \subsubsection{Comprendre les Systèmes de Recommandation}
    Les systèmes de recommandation sont devenus des outils incontournables au fils du temps. Ils permettent aux utilisateurs d'être dirigé vers des contenus pertinents et personnalisés parmi une mutilitude de choix, en s'appuyant sur des données comportementales, des préférences et des connaissances du contexte. Cette recherche retrace l'évolution des approches de recommandation, de leurs fondements les plus simples à des méthodes d'intelligence artificielle avancée, en s'appuyant sur l'article : \href{https://medium.com/@eliasah/delving-deeper-into-recommender-systems-from-basics-to-state-of-the-art-d92ee8e277f2}{ Delving Deeper into Recommender Systems: From Basics to State-of-the-Art.}
    \subparagraph{Evolution Chronologique}

    \begin{itemize}
        \item Années 1990 - Premiers Modèles:

        \textbf{Le Filtrage Collaboratif (CF)} repose sur l'idée que des utilisateurs ayant patagé des préférences similaires dans le passé auront probablement des préférences semblables à l'avenir. Il existe deux variantes:
        \begin{itemize}
            \item \textbf{User-based CF: }recherche des utilisateurs similaires à l'utilisateur cible pour recommander les objets qu'ils ont aimés.
            \item \textbf{Item-based CF: }recherche des objets similaires à ceux déjà aimés par l'utilisateur pour proposer des recommandations
        \end{itemize}
        \textbf{Filtrage basé sur le Contenue (CB)} s'appuie uniquement sur les comportements passés de l'utilisateur, en particulier ses interactions avec certains objets. Contrairement au CF, il ne tient pas compte de la communauté mais des caractéristiques des éléments.
        \newline

        \item Années 2000 - Hybridation et Deep Learning:

        \textbf{Modèles hybrides} Ces modèles combinent CF et CB pour bénéficier de leurs avantages respectifs et une amélioration du démarrage à froid.

        \textbf{Début de l'apprentissage profond} L'arrivée du deep learning a introduit une nouvelle manière de représenter utilisateurs et objets à l'aide de réseaux de neurones capables d'extraire des caractéristiques complexes, non linéaires et profondes.
        \newline
        \item Années 2010 - Contexte et Connaissances:

        Les systèmes de \textbf{context-aware} prennent maintenant en compte des informations telles que le temps, la localisation, le dispositif utilisé ou encore l'état émotionnel.

        Les systèmes \textbf{knowledge-bases}, eux, utilisent des bases de connaissance et des bases de règles explicites pour mieux cerner les besoins utilisateurs, particulièrement utiles dans des cas de niches où les données sont rares.
        \newline
        \item Années 2020 - Intelligence Renforcée et Explicabilité:

        \textbf{La Recommandation par Apprentissage par Renforcement (RL)} permet une approche sequentille et interactive. Le système apprend à adapter ses recommandations en fonction des réactions de l'utilisateur. L'algorithme explore l'espace des solutions pour améliorer ses retours.

        \textbf{La Recommandation Explicable} fournit une justification compréhensible à l'utilisateur, améliorant ainsi la confiance et la transparence
    \end{itemize}

    \subparagraph{Types de Systèmes de recommandation:}
    \begin{itemize}
        \item \textbf{Basé sur la mémoire}: Filtrage collaboratif simple
        \item \textbf{Basé sur un modèle}: Factorisation de matrice, réseaux de neurones, SVD
        \item \textbf{Basé sur le contenu}: utilisation des attributs des objets
        \item \textbf{Modèles hybrides}: Combine le filtrage collaboratif et filtrage basé sur le contenue
        \item \textbf{Apprentissage profond}: Réseaux de neurones
        \item \textbf{Système Contextuels}: Tiennent compte du contexte d'utilisation
        \item \textbf{Basé sur les connaissances}: Utilisent des logiques de règles, des bases de fait et ontologies
        \item \textbf{Apprentissage par renforcement}: Tiennent compte d'une interaction avec le client
        \item \textbf{Explicabilité}: Fournit une approche plus transparantes
        \item \textbf{Mutimodalité}: Combines plusieurs types de données
        \item \textbf{Protection de la vie Privée}: Utilise des techniques pour définir une forme de protection des résultats de requêtes
    \end{itemize}

    \subparagraph{Méthodes Avancées: }

    \begin{enumerate}
        \item \textbf{Filtrage Collaboratif avec ALS} (Alternating Least Squares) :
        Repose sur le fait que deux utilisateurs ayant eu des opinions similaires auront des opinions similaires ans d'autres situations. Utilise la factorisation de matrice avec une méthode d'optimisation par moindrers carrés alternés.
        \item \textbf{Singular Value Decomposition} (SVD):

        Utilisation d'une matrice de notes \(R = (utilisateur*items)\), la SVD la décompose comme : \(R \approx U . \sum .
        V^t\)

        \begin{itemize}
            \item U = matrice des facteurs latents utilisateur
            \item \(\sum=\) matrice diagonal des valeurs singulières
            \item \(V^t=\) transposé de la matrice des facteurs latents des items
        \end{itemize}
        SVD version recommandation:

        Factorisation de la Matrice \(\hat{R}_{ui} = P_u^T Q_i \)
        \newline
        \( R_{ui} = \) note prédite par l'utilisateur \(u\) pour l'item \(i\)
        \newline
        \(P_u = \) vecteur latent de l'utilisateur \(u\) (préférences)
        \newline
        \(Q_i = \) note vecteur latent de l'item\(i\) (caractéristiques)
        \newline
        Le produit scalaire donne la note préditque de \(u\) donnerait à \(i\).

        Apprentissage de \(P\) et \(Q\): \[ \min_{P, Q} \sum_{(u,i) \in K} \left( R_{ui} - P_u^T Q_i \right)^2 + \lambda \left( \lVert P_u \rVert^2 + \lVert Q_i \rVert^2 \right)\]

        Avec \(K\) l'ensemble des paires utilisateur-item connues (données d'entraînement), \(R_{ui}\) note réelle et \(\lambda\) le coefficient de régularisation

        \item \textbf{Recurrent Neural Network} (RNN):

        Le réseau de neurones permet de traiter des séquences (texte, audio, clics, utilisations ...) Il possède une mémoire interne (qui utilise l'info précédente à chaque étape) et gère les dépendances temporelles.

        À chaque instant (t), le RNN reçoit une entrée \((x_t)\) et un état caché précédent \((h_{t-1})\), puis il calcule:
        \begin{itemize}
            \item L'État caché: \(h_t = \tanh(W_h h_{t-1} + W_x x_t + b)\)
            \item  La Sortie: \(y_t = \text{softmax}(W_y h_t + b_y)\)
        \end{itemize}
        Avec :\\
        - \( h_t \) = état caché (mémoire interne) à l’instant \( t \)\\
        - \( x_t \) = entrée à l’instant \( t \)\\
        - \( y_t \) = sortie prédite à l’instant \( t \)\\
        - \( W_h, W_x, W_y \) = matrices de poids\\
        - \( b, b_y \) = biais\\
        - \( \tanh \) = fonction d’activation\\
        - \( \text{softmax} \) = utilisée pour une prédiction de classe\\

        \item \textbf{ConvNet} (CNN):\\
        Modèle de traitement spation de données (image, audio, vidéos):
        \begin{itemize}
            \item \textbf{Convolutions:} Extraction de caractéristiques locales
            \item \textbf{Pooling:} Reduction dimensionnelle
            \item \textbf{Fattening:} Prise de décision finale
        \end{itemize}

        \item \textbf{Multi-Armed Bandit: }\\
        Approche d'apprentissage par renforcement, visant à maximiser les gains et explorer l'espace d'action tout en exploitant les meilleures options (permet de recommander tout en testant de nouvelles options).


    \end{enumerate}

    \subsubsection{Collaborative filtering}
    Le filtrage collaboratif est une méthode de recommandation qui repose sur l’exploitation des interactions passées entre les utilisateurs
    et les objets.
    Contrairement au filtrage basé sur le contenu, il ne nécessite aucune information sur les caractéristiques des objets recommandés.

    \subparagraph{Fonctionnement}
    \begin{enumerate}
        \item \textbf{Collecte de données} : Récupération des interactions entre utilisateurs et objets, sous forme explicite (notes, avis) ou implicite (clics, temps passé, etc.).

        \item \textbf{Construction de la matrice utilisateur-objet} : Création d’une matrice où les lignes représentent les utilisateurs, les colonnes les objets, et les cellules contiennent les interactions.

        \item \textbf{Mesure de similarité} : Calcul de la similarité entre utilisateurs (user-based) ou entre objets (item-based) à l’aide de fonctions telles que la similarité cosinus ou le coefficient de corrélation de Pearson.

        \item \textbf{Prédiction} : Estimation de la préférence d’un utilisateur pour un objet non encore évalué, en se basant sur les préférences des utilisateurs ou objets similaires.

        \item \textbf{Génération de recommandations} : Sélection des objets les plus susceptibles d’intéresser l’utilisateur cible.
    \end{enumerate}

    \subparagraph{Exemple illustratif}
    Considérons la matrice suivante représentant les notes de films par trois utilisateurs :

    \begin{center}
        \begin{tabular}{|c|c|c|c|c|}
            \hline
            & Film A & Film B & Film C & Film D \\
            \hline
            Utilisateur 1 & 5 & ? & 4 & 2 \\
            \hline
            Utilisateur 2 & 4 & 3 & 5 & 1 \\
            \hline
            Utilisateur 3 & 2 & 4 & 1 & 5 \\
            \hline
        \end{tabular}
    \end{center}

    Ici, le système peut prédire la note que l'utilisateur 1 donnerait au \textit{Film B}, en se basant sur les préférences des utilisateurs 2 et 3, jugés similaires selon leurs comportements passés.

    \subparagraph{Avantages}
    \begin{itemize}
        \item \textbf{Pas besoin de métadonnées} : Il peut fonctionner sans connaître les caractéristiques des objets à recommander.
        \item \textbf{Recommandations personnalisées} : Il permet de proposer des contenus pertinents et parfois inattendus grâce à l’analyse des préférences collectives.
        \item \textbf{Adaptabilité} : Le système évolue avec les comportements des utilisateurs, ce qui le rend dynamique.
    \end{itemize}

    \subparagraph{Inconvénients}
    \begin{itemize}
        \item \textbf{Problème du démarrage à froid (cold start)} : Difficile de faire des recommandations précises pour un nouvel utilisateur ou un nouvel objet sans historique d'interactions.
        \item \textbf{Sparsité des données} : Les matrices utilisateur-objet sont souvent très clairsemées, ce qui complique la détection de similarités fiables.
        \item \textbf{Dépendance au comportement collectif} : Il peut recommander des objets peu pertinents si les utilisateurs similaires ont des goûts trop différents ou incohérents.
    \end{itemize}

    \subparagraph{Applications}
    \begin{itemize}
        \item \textbf{Divertissement} : Netflix, Spotify pour recommander des films ou de la musique.
        \item \textbf{E-commerce} : Amazon pour proposer des produits selon les comportements d’achat d’utilisateurs similaires.
        \item \textbf{Éducation} : Recommandation de cours ou ressources pédagogiques.
        \item \textbf{Réseaux sociaux} : Suggestion de contacts, contenus ou groupes.
    \end{itemize}

\subsubsection{Factorisation de matrice}
$ $\\
La factorisation de matrice \cite{matrix_fac} est une technique de recommandation user-based qui approxime les préférences des utilisateurs par le produit de deux matrices de plus 
faible dimension. Ces matrices représentent des caractéristiques latentes des utilisateurs et des items — ici, les films. Comme évoqué précédemment, cette approximation peut être 
obtenue à l’aide de l’algorithme des moindres carrés alternés ou de la descente de gradient stochastique .
Cette méthode est particulièrement adaptée aux systèmes de recommandation car elle s’applique efficacement à de grands ensembles de données, gère bien la sparsité des notations, et 
peut être étendue pour intégrer des informations supplémentaires (comme des métadonnées ou du contenu).\\
\\
\underline{Par exemple :}\\
\\
Considérons une matrice de notes \( R \) représentant les notes données par 2 utilisateurs à 4 films :\\
\[R = 
\begin{bmatrix}
5 & 3 & 0 & 1 \\
4 & 0 & 0 & 1 \\
\end{bmatrix}
\]
\\
où \( R_{ij} \) est la note donnée par l'utilisateur\( i \) au film \( j \), et  représente une note manquante.\\
L'objectif de la factorisation est donc d'approcher \( R \) par le produit de deux matrices : \(R \approx U \cdot V\).
En partant de deux matrices de tailles arbittraire est en corrigeant les erreurs, on peut obtenir une approximation de la matrice de notes \( R \) comme :\\
\[
R \approx 
\begin{bmatrix}
1.5 & 0.5 \\
1.2 & 0.4 \\
\end{bmatrix}
\cdot
\begin{bmatrix}
3.0 & 1.5 & 0.5 & 0.2 \\
1.0 & 1.0 & 0.2 & 0.5 \\
\end{bmatrix}
=
\begin{bmatrix}
5.00 & 2.75 & 0.85 & 0.55 \\
4.00 & 2.20 & 0.68 & 0.44 \\
\end{bmatrix}
\] $ $\\
Avec cette factorisation, la méthode prédit alors que l'utilisateur 1 donnerait une note 
proche de 0.85 au troisième film et l'utilisateur 2 donnerait une note provhe de 0,2.\\
Toutefois, cette approche présente certaines limites. Tout d'abord, elle necessite une étude 
profonde de ses hyperparamètres pour obtenir des résultats pertinents, notamment le nombre de 
facteurs latents à utiliser. De plus, elle est sensible au problème du démarrage à froid pour 
les nouveaux utilisateurs ou items -films dans le cas présent- et a un coût de calcul qui peut 
devenir important selon la taille du jeu de données.

\subsection{Système de recommandation à froid}
$ $\\
Au fil du temps, plusieurs approches ont été développées pour répondre aux problèmes de recommandation à froid, 
c’est-à-dire lorsqu’il s’agit de recommander de nouveaux films ou de faire des suggestions à de nouveaux utilisateurs. 
Parmi elles, on peut distinguer les principales suivantes :
\begin{itemize}
    \item \textbf{Les méthodes basées sur le contenu (content-based)}, comme présenté par Schein, A. I., Popescul, A., Ungar, L. H., 
    et Pennock, D. M. (2002) \cite{schein2002_methods}, utilisent les caractéristiques des items — ici, 
    des films — comme la description, le genre ou les acteurs. En calculant la similarité entre les caractéristiques 
    de films (par exemple avec la similarité cosinus), on peut recommander des films proches de ceux déjà appréciés 
    par un utilisateur.
    \item \textbf{Les approches hybrides} combinent le filtrage collaboratif et le filtrage basé sur le contenu afin 
    de bénéficier des avantages des deux. Par exemple et comme présenté par Xiaoyuan Su et Taghi M. Khoshgoftaar (2010) \cite{su_cf_survey}, plusieurs implémentation sont possible. Il est possible 
    d'implémenter séparemment une méthode collaborative et une méthode basée sur le contenu, puis de combiner les résultats pour générer des recommandations 
    plus pertinentes ou encore d'implémenter un modèle unifié, intégrant à la fois des caractéristiques du contenu et du filtrage collaboratif.
    L’ajout progressif d’interactions utilisateur permet ainsi d’améliorer la précision des recommandations.
    \item \textbf{Les méthodes basées sur le clustering} regroupent les utilisateurs ou les items selon leurs caractéristiques 
    communes, comme présenté par Nguyen et al. (2024)\cite{nguyen2024_ere} ou encore Snider (2019) \cite{snider_unsupervised}.
    L'objectif de cette approche est de générer des recommandations en s’appuyant sur la structure des groupes formés en recommendant, par exemple ,
    un unique cluster de données pour limiter la diversité ou inversement en recommendant des films de plusieurs clusters pour la favoriser.
\end{itemize}

\subsection{Confidentialité}
\subsubsection{Chiffrement homomorphe}
$ $\\
    Le chiffrement homomorphe est une technique de cryptographie qui permet d'effectuer des calculs sur des données chiffrées sans avoir besoin de les déchiffrer au préalable mais dont le résultat déchiffré conserve les opérations entre les données claires.
    Pour cela, plusieurs catégories de chiffrements existent:\\
    \begin{itemize}
        \item \textbf{Chiffrement partiellement homomorphe}: Il permet de réaliser des opérations sur des données chiffrées pour une loi spécifique, par exemple l'addition ou la multiplication entre des données chiffrées.
        \item \textbf{Chiffrement presque entièrement homomorphe}: Il permet de réaliser un nombres limité d'opérations sur des données chiffrées pour plusieurs lois spécifiques, par exemple l'addition et la multiplication entre des données chiffrées, à cause d'une accumulation de bruit.
        \item \textbf{Chiffrement entièrement homomorphe}: Il permet de réaliser un nombre illimité d'opérations sur des données chiffrées pour toutes les lois possibles, mais il est limité par la taille du bruit accumulé lors des opérations.
    \end{itemize}
    $ $\\
    Dans le cadre de ce projet nous nous sommes intéressés particulièrement au chiffrement entièrement homomorphe pour sa flexibilité d'utilisation pour différents système de recommandations.\\
    Ainsi, plusieurs approches existent pour la mise en place du chiffreemnt homomorphe: \\
    \begin{itemize}
        \item \textbf{Chiffrement DGHV avec bootstrapping \cite{boots}}: Le chiffrement DGHV \cite{dghv} est un système de chiffrement homomorphe, opérant sur des entiers, basé sur le problème de la somme de sous-ensembles clairsemée et le problème du PGCD approché.
        \item \textbf{Chiffrement GSW avec bootstrapping\cite{boots}}: Le chiffrement GSW \cite{gsw} est un système de chiffrement homomorphe, opérant sur des bits, basé sur le problème de la factorisation des entiers et le problème du logarithme discret.
        \item \textbf{Chiffrement TFHE}: Le chiffrement TFHE \cite{tfhe} est un système de chiffrement homomorphe, opérant sur des bits, basé sur la version torique du problème Learning With Errors.
    \end{itemize}
$ $\\
Toutefois, même si si le chiffrement homomorphe permet de préserver la confidentialité des données, leurs utilisations présentent plusieurs contraintes:
\begin{itemize}
    \item Les données chiffrées sont généralement plus volumineuses que les données claires, ce qui peut poser des problèmes de stockage et de transmission de données. Par exemple,
    dans l'article de I. Chillotti, N. Gama, M. Georgieva, et M. Izabachène. (2016) \cite{end_size} où on apprend en conclusion de l'article que la taille du texte chiffré est 400 000 fois plus grand que celui d'origine.
    \item L'utilisation de "bootstrapping" \cite{boots} pour limiter l'accumulation de bruit peut augmententer le temps de calcul avec un nombre d'opérations significatifs réalisées. En effet, servant de contrôle de la taille 
    \item du bruit, les opérations de "bootstrapping" augmentent les opérations réalisées sur le texte chiffré, pouvant ainsi influer sur le temps de calcul.
    augmentent aussi le temps de calcul.
    \item La mise en place sans ressouces externes est complexe et les ressources externes - sans prendre en compte leurs fiabilités - sont principalement disponible avec des bibliothèques
     en C++ ou RUST, comme Microsoft SEAL, HElib ou PALISADE, ce qui complique l'interaction avec d'autres langages de programmation comme JAVA.
\end{itemize}

\subsubsection{Differential privacy}
$ $\\
La confidentialité différentielle est une approche qui vise à garantir la protection de la vie privée des individus dans les ensembles de données en restreignant la relation entre les données de sortie et les données de l'utilisateur.
Pour cela, plusieurs approches existent:\\
\begin{itemize}
    \item \textbf{Mécanisme exponentiel}: Le mécanisme exponentiel \cite{programming_dp} permet de sélectionner aléatoirement un élément parmi un ensemble de données, en favorisant les éléments ayant le plus de poids selon une fonction d'évaluation donnée.
    \item \textbf{Réponse aléatoire}: Le mécanisme de réponse aléatoire telle qu'utilisé dans le bulletin de psychologie écrit par de BEGIN G. et SAVARD F. \cite{psychologie} vise à brouiller les réponses données en remplaçant aléatoirement certaines réponses par des valeurs aléatoires.
    En connaissant la probabilité d'obtenir une valeur aléatoire, il est alors possible d'estimer la proportion de données réelles ainsi que la variance au sein des données.
    \item \textbf{\emph{K-anonymisation} et \emph{L-diversité}}: La \emph{K-anonymisation}\cite{kanonymisation} et la \emph{L-diversité} consistent à masquer les éléments de quasi-identification d'un
    individu en le regroupant avec $K-1$ autres individus dans une représentations plus large, tout en conservant la visibilité des $L$ informations spécifiques à chaque utilisateurs et destinées à être partagées.
    \item \textbf{Mécanisme de Laplace ou Gaussien}: Le mécanisme de Laplace ou Gaussien \cite{laplace&gauss} consiste à altérer les données des utilisateurs pour masquer les données réelles tout en conservant la répartition moyenne des données en ajoutant un bruit aléatoire.
\end{itemize}

\section{Démarche choisie}
\subsection{Motivations du choix}
\subsubsection{Confidentialité des données}
$ $\\
Le cadre de ce projet est de mettre en place un système de recommandation de films respectant la vie privée des utilisateurs. Nous avons
considéré que la base de données des utilisateurs ainsi que les films proposés pouvaient évoluer au fil du temps.
Pour la protection de la vie privée des utilisateurs, nous avions considéré l'utilisation du chiffrement homomorphe TFHE, mais
la complexité de son implémentation et de son utilisation, avec notamment l'interaction entre différents langages de programmation (JAVA, C++, RUST),
ainsi que la complexité de l'utilisation de l'apprentissage machine avec une bibliothèque spécialisée, nous a poussés à nous intéresser davantage à la confidentialité différentielle.\\
Plus précisément, nous nous sommes particulièrement intéressés à la mise en place du mécanisme de bruitage et du mécanisme exponentiel pour la mise
en place de la confidentialité différentielle pour, respectivement, les recommandations pour un nouvel utilisateur et les recommandations personnalisées
d'un utilisateur ayant déjà évalué une certaine quantité de films.\
En ce qui concerne le mécanisme de génération du bruit, nous avons choisi d'utiliser le mécanisme de Laplace pour masquer les données des utilisateurs.\
Ce choix est motivé par le contexte de ce projet. En effet, les utilisateurs peuvent modifier leur evaluation d'un film. Dans cet optique, et contrairement au 
mécanisme gaussien, nous avons favorisé le mécanisme de Laplace car c'est un mécanisme $\epsilon$-indistinguable. C'est-à-dire qu'il garantit qu'une 
modification d'une entrée dans une base de données crée une modification bornée de la distribution de probabilité.\
De plus, étant donné que la base de données initale possède relativement peu d'évaluation utilisateurs pour chaque film, le mécanisme de Laplace est privilégié
puisque la génération de bruit à forte valeur est moins probable que pour le mécanisme gaussien, dû à une distribution plus centré en 0 pour la courbe Laplacienne, 
ce qui permet de garantir une meilleure précision dans l'étude de la moyenne des évaluations des films.\\
Enfin, dans le cadre d'une protection des données privée des utilisateurs, nous avons eu la volonté de limité l'utilisation de ressources externes 
pour la génération des données bruitées afin de reposer au minimum sur la fiabilité de ces ressources. Ce faisant, l'implémentation du mécanisme Gaussien 
impliquerait l'implémentation complexe, avec le temps disponible, de l'approximation de l'inverse de la fonction:
\begin{equation}
    F(x) = \int_{-\infty}^{x} \frac{1}{\sqrt{2\pi}} e^{-\frac{t^2}{2}} dt
\end{equation}
afin de générer le bruit gaussien. Ainsi, nous avons privilégié l'implémentation plus simple du mécanisme de Laplace qui s’adapte mieux aux traitements 
ponctuels sur des bases de données de taille variable, ccorrespondant aux besoins de notre système d'entrainement pour nos recommandations.\
En complément, et comme présenté précédemment, nous avons considéré l'utilisation du mécanisme exponentiel pour une sélection aléatoire biaisée d'un film recommandé.
Cette approche permet à la fois de favoriser certains films - ici ceux qui ont une note moyenne la plus éloigné de 2.5 pour recommender des films qui n'ont jamais été noté ou des
films avec une bonne notation - grâce à une fonction d'utilité définie dans le système, tout en limitant le risque que 
l'utilisateur puisse extraire des informations individuelles sur les autres utilisateurs ayant permis de générer les recommandations avec une bonne 
calibration.

\subsubsection{Models de recommandations}
$ $\\
Pour le système de recommendation, nou savons choisi de mettre en place deux approches pour la recommandation de films: un systeme se basant sur le SVD pour un 
individus connu par le système - individu ayant déjà noté un certain nombre de films - et un autre système de recommendation basé sur la clustering non supervisé 
pour la recommendation à froid pour un nouvel utilisateur.

\begin{itemize}
    \item Pour le SVD
    \item Pour le système de clustering:\\
    $ $\\
    Le système de recommendation mit en place se base sur un clustering non supervisé des films, à l'image de Snider 2019 \cite{snider_unsupervised} , ainsi que sur des statistiques globales issues de la base de données.
    L'objectif de ce système de recommendation est, à la fois, de représenter la diversité de la base de données, de recommender des films peu noté (et donc possiblement 
    peu vus) pour obtenir plus d'informations statistiques sur ces films mais aussi de recommander des films ayant une note moyenne élevée dans notre base de données.
    Plus précisément, notre système sélectionne les films ayant une note moyenne supérieure ou égale à un seuil (ici, 3)  ou ayant un nombre d’évaluations inférieur ou égal à un seuil (ici, 2).\\
    Pour ces films, des vecteurs de caractéristiques sont générés à partir de leurs informations descriptives (genre, synopsis, année,jour et mois de sortie), 
    puis normalisés pour permettre des comparaisons fiables. Nous appliquons ensuite une réduction de dimension (via l’algorithme UMAP) suivie d’un clustering 
    non supervisé (DBSCAN), permettant de regrouper les films selon leur similarité cosinus. Enfin, pour encourager la diversité, le système sélectionne aléatoirement un cluster, puis, de 
    manière biaisée pour favoriser les films les moins notés, un film au sein de celui-ci.\\
    La mise en place de cette approche permet ainsi de rendre équiprobable la sélection de films de différents cluster tout en recommendant, de manière paramétrable, des films les moins notée.
\end{itemize}




    \subsection{Implémentation dans le système}
    \subsection{Limites et perspectives}


    \section{Résultats expérimentaux}
    \subsection{Précision des recommandations}
    \subsection{Performances computationnelles}
    \subsection{Mesure de la confidentialité}
    \subsection{Résumé}


\begin{thebibliography}{99}

\bibitem{psychologie}
J.-P. Rolland, « La technique de la réponse aléatoire : un moyen de contrôler la désirabilité sociale dans la mesure de l'estime de soi », \emph{Bulletin de Psychologie}, vol. 33, no. 343, 1979. [En ligne]. Disponible : \url{https://www.persee.fr/doc/bupsy_0007-4403_1979_num_33_343_1128} [Consulté le 28 mai 2025].

\bibitem{schein2002_methods}
A. I. Schein, A. Popescul, L. H. Ungar, et D. M. Pennock, « Methods and Metrics for Cold-Start Recommendations », in \emph{Proc. 25th Annu. Int. ACM SIGIR Conf. Res. Dev. Inf. Retr. (SIGIR '02)}, 2002, pp. 253–260. [En ligne]. Disponible : \url{https://www.researchgate.net/publication/221300490_Methods_and_Metrics_for_Cold-Start_Recommendations} [Consulté le 28 mai 2025].

\bibitem{kanonymisation}
Wikipedia, « K-anonymisation », 2006. [En ligne]. Disponible : \url{https://fr.wikipedia.org/wiki/K-anonymisation} [Consulté le 28 mai 2025].

\bibitem{su_cf_survey}
X. Su et T. M. Khoshgoftaar, « A Survey of Collaborative Filtering Techniques », \emph{IEEE Trans. Knowl. Data Eng.}, vol. 22, no. 1, pp. 107–117, 2010. [En ligne]. Disponible : \url{https://pages.stern.nyu.edu/~atuzhili/pdf/TKDE-Paper-as-Printed.pdf} [Consulté le 28 mai 2025].

\bibitem{laplace&gauss}
C. Dwork et A. Roth, \emph{The Algorithmic Foundations of Differential Privacy}, Found. Trends Theor. Comput. Sci., vol. 9, no. 3–4, pp. 211–407, 2014. [En ligne]. Disponible : \url{https://www.cis.upenn.edu/~aaroth/Papers/privacybook.pdf} [Consulté le 28 mai 2025].

\bibitem{end_size}
I. Chillotti, N. Gama, M. Georgieva, et M. Izabachène, « Faster Fully Homomorphic Encryption: Bootstrapping in Less Than 0.1 Seconds », \emph{Cryptology ePrint Archive}, Rapport 2016/870, 2016. [En ligne]. Disponible : \url{https://eprint.iacr.org/2016/870} [Consulté le 28 mai 2025].

\bibitem{snider_unsupervised}
G. Snider, « Unsupervised Product Clustering: Exploring the Cold Start Problem », \emph{SSENSE Tech Blog}, Medium, 2019. [En ligne]. Disponible : \url{https://medium.com/ssense-tech/unsupervised-product-clustering-exploring-the-cold-start-problem-8053ef04bac9} [Consulté le 28 mai 2025].

\bibitem{matrix_fac}
E. Azar, « Deep Dive into Matrix Factorization for Recommender Systems: From Basics to Implementation », Medium, 2020. [En ligne]. Disponible : \url{https://medium.com/@eliasah/deep-dive-into-matrix-factorization-for-recommender-systems-from-basics-to-implementation-79e4f1ea1660} [Consulté le 28 mai 2025].

\bibitem{dghv}
E. Goblé et R. Gatelier, « Le chiffrement DGHV », Université de Technologie de Compiègne. [En ligne]. Disponible : \url{https://www.utc.fr/~wschon/sr06/tx_chiffrement_homomorphe/pages/dghv.html} [Consulté le 28 mai 2025].

\bibitem{gsw}
E. Goblé et R. Gatelier, « GSW », Université de Technologie de Compiègne. [En ligne]. Disponible : \url{https://www.utc.fr/~wschon/sr06/tx_chiffrement_homomorphe/pages/vecteurs_propres_approx.html} [Consulté le 28 mai 2025].

\bibitem{boots}
E. Goblé et R. Gatelier, « Le Bootstrap », Université de Technologie de Compiègne. [En ligne]. Disponible : \url{https://www.utc.fr/~wschon/sr06/tx_chiffrement_homomorphe/pages/bootstrapping.html} [Consulté le 28 mai 2025].

\bibitem{programming_dp}
\emph{Programming Differential Privacy}, « Chapter 9 — Fully Homomorphic Encryption (FHE) ». [En ligne]. Disponible : \url{https://programming-dp.com/ch9.html} [Consulté le 28 mai 2025].

\bibitem{tfhe}
B. Chandran, A. Ghoshal, S. Halevi, S. Ranellucci, et N. P. Smart, « Faster Homomorphic Comparison Operations for BGV and BFV », \emph{Cryptology ePrint Archive}, Rapport 2023/958, 2023. [En ligne]. Disponible : \url{https://eprint.iacr.org/2023/958} [Consulté le 28 mai 2025].

\bibitem{nguyen2024_ere}
Q. Nguyen, M. Naghiaei, et Y. Zhang, « Cold-start Recommendation by Personalized Embedding Region Elicitation », \emph{arXiv preprint} arXiv:2406.00973, 2024. [En ligne]. Disponible : \url{https://arxiv.org/abs/2406.00973} [Consulté le 28 mai 2025].

\end{thebibliography}

\section*{Annexes}
\addcontentsline{toc}{section}{Annexes}
Données supplémentaires, résultats détaillés, ou code pertinent.

\end{document}
